 /******************************************************************************
 *
 * Module: UltraSonic
 *
 * File Name: UltraSonic.c
 *
 * Description: Source file for the AVR UltraSonic driver
 *
 * Author:
 *
 *******************************************************************************/
#include "icu.h"
#include "std_types.h"
#include "gpio.h"
#include "util/delay.h"
#include <math.h>
#include "ultrasonic.h"
/*******************************************************************************
 *                      global variables                                 *
 *******************************************************************************/
uint8 g_edgeCount = 0;
uint16 g_timeHigh = 0;




/*******************************************************************************
 * [Function Name] : Ultrasonic_edgeProcessing
 *
 * [Description]   : The call_back function called by the ICU driver.
 * 					 It's used to calculate the high time (pulse time)
 * 					 generated by the ultrasonic sensor.
 *
 * [Args]          : NONE
 *******************************************************************************/

void Ultrasonic_edgeProcessing(void)

{
		g_edgeCount++;
		if(g_edgeCount == 1)
		{
			/*
			 * Clear the timer counter register to start measurements from the
			 * first detected rising edge
			 */
			Icu_clearTimerValue();
			/* Detect falling edge */
			Icu_setEdgeDetectionType(FALLING);
		}
		else if(g_edgeCount == 2)
		{
			/* storing the value of the 'ICR1' register in the g_timerValue variable where it's global *
		 	* as it will be used again in another function which is called "ULTRASONIC_readDistance". */

			g_timeHigh = Icu_getInputCaptureValue();
			/* Detect rising edge */
			

			Icu_setEdgeDetectionType(RISING);
			g_edgeCount=0;
		}


}
/*******************************************************************************
 * [Function Name] : Ultrasonic_init
 *
 * [Description]   : Initialize the ICU driver as required.
 * 					 Setup the ICU call back function.
 * 					 Setup the direction for the trigger pin as output pin through the GPIO driver
 *
 * [Args]          : NONE
 *******************************************************************************/

void Ultrasonic_init(void)
{
	Icu_ConfigType Icu_Config = {F_CPU_8,RISING};
	/* Set the Call back function pointer in the ICU driver */
	Icu_setCallBack(Ultrasonic_edgeProcessing);
	/* Initialize the ICU driver */
	Icu_init(&Icu_Config);
	/*setup the direction of the trigger pin as output pin through the gpio driver*/
	GPIO_setupPinDirection(PORTB_ID,PIN5_ID,PIN_OUTPUT);
	/*disabling trigger pin*/
	GPIO_writePin(PORTB_ID,PIN5_ID,LOGIC_LOW);

}
/*******************************************************************************
 * [Function Name] : Ultrasonic_Trigger
 *
 * [Description]   : Send the Trigger pulse to the ultrasonic
 *
 * [Args]          : NONE
 *******************************************************************************/
void Ultrasonic_Trigger(void)
{
	GPIO_writePin(PORTB_ID,PIN5_ID,1);
	_delay_us(1);
	GPIO_writePin(PORTB_ID,PIN5_ID,0);

}
/*******************************************************************************
 * [Function Name] : Ultrasonic_readDistance
 *
 * [Description]   : Send the trigger pulse by using Ultrasonic_Trigger function.
 * 					 Start the measurements by the ICU from this moment and returning
 * 					 the measured distance.
 *
 * [Args]          : NONE
 * [Returns]       : Distance (The measured distance in Centimeter).
 * [NOTE]          : The calculated distance will be updated when use another prescaler and CPU freq
 *******************************************************************************/

uint16 Ultrasonic_readDistance(void)
{
	static uint32 distance;
	/*for calibrating the reading due to ultrasonic tolerance*/
	static uint32 distance_calibration;

	/*enabling triggering*/
	Ultrasonic_Trigger();
	/*  Sound velocity =   343.00 m/s = 34300 cm/s
	    The distance of Object (in cm) = (soundVelocity * TimerValue)/2
		Now, here we have selected an internal 16 MHz oscillator frequency for ATmega32, with prescaler FCPU/8
		for timer frequency. Then time to execute 2 instruction is 1us.
		So, the timer gets incremented after 1us time elapse.
                 = 17150 x (TIMER value) x (prescaler/16) x 10^-6 cm
                 = (prescaler/16) x (TIMER value)*0.01715 cm
				 in this case i will work with no prescaler so prescaler=1
				 distance is divided by 2 because it is distance of going and return back*/

	/******** distance =(g_timeHigh*0.01715)*(Prescaler/FCPU)+1  ***********/

	 distance = (g_timeHigh*0.01715)/2+1;
	 /* (+1) because of ultrasonic tolerence*/
	 /*Also for calibration*/

	 if(distance>=342){
	 		distance_calibration=distance+2;
	 		return distance_calibration;
	 	}
	 	else if(distance>=154&&distance<342){
	 		distance_calibration=distance+1;
	 		return distance_calibration;
	 	}

	 	else{
	 	return distance;}

	 	return 1;



}



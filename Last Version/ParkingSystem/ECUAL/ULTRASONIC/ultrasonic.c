/******************************************************************************
 *
 * Module: UltraSonic
 *
 * File Name: UltraSonic.c
 *
 * Description: Source file for the AVR UltraSonic driver
 *
 * Author:
 *
 *******************************************************************************/
#include "../../MCAL/ICU/icu.h"
#include "../../UTILITIES/std_types.h"
#include "../../MCAL/DIO/gpio.h"
#include "util/delay.h"
#include <math.h>
#include "ultrasonic.h"
#include <avr/interrupt.h>
/*******************************************************************************
 *                      global variables                                 *
 *******************************************************************************/
uint8 g_edgeCount = 0;
uint16 g_frontLeftTimeHigh = 0;
uint16 g_frontRightTimeHigh = 0;
uint16 g_rearLeftTimeHigh = 0;
uint16 g_rearRightTimeHigh = 0;

Ultrasonic_Sensor_ID g_sensorID = FRONT_RIGHT;

/*******************************************************************************
 * [Function Name] : Ultrasonic_edgeProcessing
 *
 * [Description]   : The call_back function called by the ICU driver.
 * 					 It's used to calculate the high time (pulse time)
 * 					 generated by the ultrasonic sensor.
 *
 * [Args]          : NONE
 *******************************************************************************/

void Ultrasonic_edgeProcessing(void)

{
	g_edgeCount++;
	if (g_edgeCount == 1) {
		/*
		 * Clear the timer counter register to start measurements from the
		 * first detected rising edge
		 */
		Icu_clearTimerValue();
		/* Detect falling edge */
		Icu_setEdgeDetectionType(FALLING);
	} else if (g_edgeCount == 2) {
		/* storing the value of the 'ICR1' register in the g_timerValue variable where it's global *
		 * as it will be used again in another function which is called "ULTRASONIC_readDistance". */

		g_frontRightTimeHigh = Icu_getInputCaptureValue();
		/* Detect rising edge */
		Icu_setEdgeDetectionType(RISING);
		//DIO_togglePin(FRONT_ULTRASONIC_VCC_PORT_ID,FRONT_ULTRASONIC_VCC_PIN_ID);
		//DIO_togglePin(REAR_ULTRASONIC_VCC_PORT_ID,REAR_ULTRASONIC_VCC_PIN_ID);
		DIO_writePin(FRONT_RIGHT_ULTRASONIC_VCC_PORT_ID,
				FRONT_RIGHT_ULTRASONIC_VCC_PIN_ID, LOGIC_LOW);

	} else if (g_edgeCount == 3) {
		/*
		 * Clear the timer counter register to start measurements from the
		 * first detected rising edge
		 */
		Icu_clearTimerValue();
		/* Detect falling edge */
		Icu_setEdgeDetectionType(FALLING);
	} else if (g_edgeCount == 4) {
		/* storing the value of the 'ICR1' register in the g_timerValue variable where it's global *
		 * as it will be used again in another function which is called "ULTRASONIC_readDistance". */

		g_frontLeftTimeHigh = Icu_getInputCaptureValue();
		/* Detect rising edge */
		Icu_setEdgeDetectionType(RISING);
		DIO_writePin(FRONT_LEFT_ULTRASONIC_VCC_PORT_ID,
				FRONT_LEFT_ULTRASONIC_VCC_PIN_ID, LOGIC_LOW);

	} else if (g_edgeCount == 5) {
		/*
		 * Clear the timer counter register to start measurements from the
		 * first detected rising edge
		 */
		Icu_clearTimerValue();
		/* Detect falling edge */
		Icu_setEdgeDetectionType(FALLING);
	} else if (g_edgeCount == 6) {
		/* storing the value of the 'ICR1' register in the g_timerValue variable where it's global *
		 * as it will be used again in another function which is called "ULTRASONIC_readDistance". */

		g_rearRightTimeHigh = Icu_getInputCaptureValue();
		/* Detect rising edge */
		Icu_setEdgeDetectionType(RISING);
		DIO_writePin(REAR_RIGHT_ULTRASONIC_VCC_PORT_ID,
				REAR_RIGHT_ULTRASONIC_VCC_PIN_ID, LOGIC_LOW);
	} else if (g_edgeCount == 7) {
		/*
		 * Clear the timer counter register to start measurements from the
		 * first detected rising edge
		 */
		Icu_clearTimerValue();
		/* Detect falling edge */
		Icu_setEdgeDetectionType(FALLING);
	} else if (g_edgeCount == 8) {
		/* storing the value of the 'ICR1' register in the g_timerValue variable where it's global *
		 * as it will be used again in another function which is called "ULTRASONIC_readDistance". */
		g_rearLeftTimeHigh = Icu_getInputCaptureValue();
		/* Detect rising edge */
		Icu_setEdgeDetectionType(RISING);
		DIO_writePin(REAR_LEFT_ULTRASONIC_VCC_PORT_ID,
				REAR_LEFT_ULTRASONIC_VCC_PIN_ID, LOGIC_LOW);
		g_edgeCount = 0;
	} else {
		/* Do nothing */
	}

}
/*******************************************************************************
 * [Function Name] : Ultrasonic_init
 *
 * [Description]   : Initialize the ICU driver as required.
 * 					 Setup the ICU call back function.
 * 					 Setup the direction for the trigger pin as output pin through the GPIO driver
 *
 * [Args]          : NONE
 *******************************************************************************/

void Ultrasonic_init(void) {

	DIO_setupPinDirection(FRONT_RIGHT_ULTRASONIC_VCC_PORT_ID,
			FRONT_RIGHT_ULTRASONIC_VCC_PIN_ID, PIN_OUTPUT);
	DIO_setupPinDirection(FRONT_LEFT_ULTRASONIC_VCC_PORT_ID,
			FRONT_LEFT_ULTRASONIC_VCC_PIN_ID, PIN_OUTPUT);
	DIO_setupPinDirection(REAR_RIGHT_ULTRASONIC_VCC_PORT_ID,
			REAR_RIGHT_ULTRASONIC_VCC_PIN_ID, PIN_OUTPUT);
	DIO_setupPinDirection(REAR_LEFT_ULTRASONIC_VCC_PORT_ID,
			REAR_LEFT_ULTRASONIC_VCC_PIN_ID, PIN_OUTPUT);
	DIO_writePin(FRONT_RIGHT_ULTRASONIC_VCC_PORT_ID,
			FRONT_RIGHT_ULTRASONIC_VCC_PIN_ID, LOGIC_HIGH);
	DIO_writePin(FRONT_LEFT_ULTRASONIC_VCC_PORT_ID,
			FRONT_LEFT_ULTRASONIC_VCC_PIN_ID, LOGIC_LOW);
	DIO_writePin(REAR_RIGHT_ULTRASONIC_VCC_PORT_ID,
			REAR_RIGHT_ULTRASONIC_VCC_PIN_ID, LOGIC_LOW);
	DIO_writePin(REAR_LEFT_ULTRASONIC_VCC_PORT_ID,
			REAR_LEFT_ULTRASONIC_VCC_PIN_ID, LOGIC_LOW);
	/* ICU Configurations Structure */
	Icu_ConfigType Icu_Config = { F_CPU_8, RISING };
	/* Set the Call back function pointer in the ICU driver */
	Icu_setCallBack(Ultrasonic_edgeProcessing);
	/* Initialize the ICU driver */
	Icu_init(&Icu_Config);
	/*setup the direction of the trigger pin as output pin through the gpio driver*/
	DIO_setupPinDirection(FRONT_RIGHT_ULTRASONIC_TRIGGER_PORT_ID,
			FRONT_RIGHT_ULTRASONIC_TRIGGER_PIN_ID, PIN_OUTPUT);
	/*disabling trigger pin*/
	DIO_writePin(FRONT_RIGHT_ULTRASONIC_TRIGGER_PORT_ID,
			FRONT_RIGHT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_LOW);
	/*setup the direction of the trigger pin as output pin through the gpio driver*/
	DIO_setupPinDirection(FRONT_LEFT_ULTRASONIC_TRIGGER_PORT_ID,
			FRONT_LEFT_ULTRASONIC_TRIGGER_PIN_ID, PIN_OUTPUT);
	/*disabling trigger pin*/
	DIO_writePin(FRONT_LEFT_ULTRASONIC_TRIGGER_PORT_ID,
			FRONT_LEFT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_LOW);
	/*setup the direction of the trigger pin as output pin through the gpio driver*/
	DIO_setupPinDirection(REAR_RIGHT_ULTRASONIC_TRIGGER_PORT_ID,
			REAR_RIGHT_ULTRASONIC_TRIGGER_PIN_ID, PIN_OUTPUT);
	/*disabling trigger pin*/
	DIO_writePin(REAR_RIGHT_ULTRASONIC_TRIGGER_PORT_ID,
			REAR_RIGHT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_LOW);
	/*setup the direction of the trigger pin as output pin through the gpio driver*/
	DIO_setupPinDirection(REAR_LEFT_ULTRASONIC_TRIGGER_PORT_ID,
			REAR_LEFT_ULTRASONIC_TRIGGER_PIN_ID, PIN_OUTPUT);
	/*disabling trigger pin*/
	DIO_writePin(REAR_LEFT_ULTRASONIC_TRIGGER_PORT_ID,
			REAR_LEFT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_LOW);

}

/*******************************************************************************
 * [Function Name] : Ultrasonic_Trigger
 *
 * [Description]   : Send the Trigger pulse to the ultrasonic
 *
 * [Args]          : NONE
 *******************************************************************************/
void Ultrasonic_Trigger(void) {
	if (g_sensorID == FRONT_RIGHT) {
		DIO_writePin(FRONT_RIGHT_ULTRASONIC_TRIGGER_PORT_ID,
				FRONT_RIGHT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_HIGH);
		_delay_us(1);
		DIO_writePin(FRONT_RIGHT_ULTRASONIC_TRIGGER_PORT_ID,
				FRONT_RIGHT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_LOW);
	} else if (g_sensorID == FRONT_LEFT) {
		DIO_writePin(FRONT_LEFT_ULTRASONIC_TRIGGER_PORT_ID,
				FRONT_LEFT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_HIGH);
		_delay_us(1);
		DIO_writePin(FRONT_LEFT_ULTRASONIC_TRIGGER_PORT_ID,
				FRONT_LEFT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_LOW);
	} else if (g_sensorID == REAR_RIGHT) {
		DIO_writePin(REAR_RIGHT_ULTRASONIC_TRIGGER_PORT_ID,
				REAR_RIGHT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_HIGH);
		_delay_us(1);
		DIO_writePin(REAR_RIGHT_ULTRASONIC_TRIGGER_PORT_ID,
				REAR_RIGHT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_LOW);
	} else if (g_sensorID == REAR_LEFT) {
		DIO_writePin(REAR_LEFT_ULTRASONIC_TRIGGER_PORT_ID,
				REAR_LEFT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_HIGH);
		_delay_us(1);
		DIO_writePin(REAR_LEFT_ULTRASONIC_TRIGGER_PORT_ID,
				REAR_LEFT_ULTRASONIC_TRIGGER_PIN_ID, LOGIC_LOW);
	} else {
		/*Do nothing*/
	}

}
/*******************************************************************************
 * [Function Name] : Ultrasonic_readDistance
 *
 * [Description]   : Send the trigger pulse by using Ultrasonic_Trigger function.
 * 					 Start the measurements by the ICU from this moment and returning
 * 					 the measured distance.
 *
 * [Args]          : NONE
 * [Returns]       : Distance (The measured distance in Centimeter).
 * [NOTE]          : The calculated distance will be updated when use another prescaler and CPU freq
 *******************************************************************************/

uint16 Ultrasonic_readDistance(void) {
	static uint32 distance;
	/*for calibrating the reading due to ultrasonic tolerance*/
	static uint32 distance_calibration;

	/*enabling triggering*/
	Ultrasonic_Trigger();
	/*  Sound velocity =   343.00 m/s = 34300 cm/s
	 The distance of Object (in cm) = (soundVelocity * TimerValue)/2
	 Now, here we have selected an internal 16 MHz oscillator frequency for ATmega32, with prescaler FCPU/8
	 for timer frequency. Then time to execute 2 instruction is 1us.
	 So, the timer gets incremented after 1us time elapse.
	 = 17150 x (TIMER value) x (prescaler/16) x 10^-6 cm
	 = (prescaler/16) x (TIMER value)*0.01715 cm
	 in this case i will work with no prescaler so prescaler=1
	 distance is divided by 2 because it is distance of going and return back*/

	/******** distance =(g_timeHigh*0.01715)*(Prescaler/FCPU)+1  ***********/
	if (g_sensorID == FRONT_RIGHT) {
		distance = (((SOUND_SPEED * g_frontRightTimeHigh) / 2 + 1)
				* TIME_OF_INSTRUCTION);
		DIO_writePin(FRONT_LEFT_ULTRASONIC_VCC_PORT_ID,
				FRONT_LEFT_ULTRASONIC_VCC_PIN_ID, LOGIC_HIGH);
		g_sensorID = FRONT_LEFT;
	} else if (g_sensorID == FRONT_LEFT) {
		distance = (((SOUND_SPEED * g_frontLeftTimeHigh) / 2 + 1)
				* TIME_OF_INSTRUCTION);
		DIO_writePin(REAR_RIGHT_ULTRASONIC_VCC_PORT_ID,
				REAR_RIGHT_ULTRASONIC_VCC_PIN_ID, LOGIC_HIGH);
		g_sensorID = REAR_RIGHT;
	} else if (g_sensorID == REAR_RIGHT) {
		distance = (((SOUND_SPEED * g_rearRightTimeHigh) / 2 + 1)
				* TIME_OF_INSTRUCTION);
		DIO_writePin(REAR_LEFT_ULTRASONIC_VCC_PORT_ID,
				REAR_LEFT_ULTRASONIC_VCC_PIN_ID, LOGIC_HIGH);	
		g_sensorID = REAR_LEFT;
	} else if (g_sensorID == REAR_LEFT) {
		distance = (((SOUND_SPEED * g_rearLeftTimeHigh) / 2 + 1)
				* TIME_OF_INSTRUCTION);
			DIO_writePin(FRONT_RIGHT_ULTRASONIC_VCC_PORT_ID,
				FRONT_RIGHT_ULTRASONIC_VCC_PIN_ID, LOGIC_HIGH);
		g_sensorID = FRONT_RIGHT;
	} else {
		/*Do nothing*/
	}
	// distance = (g_timeHigh*0.01715)/2+1;

	/* (+1) because of ultrasonic tolerence*/
	/*Also for calibration*/

	if (distance >= 342) {
		distance_calibration = distance + 2;
		return distance_calibration;
	} else if (distance >= 154 && distance < 342) {
		distance_calibration = distance + 1;
		return distance_calibration;
	}

	else {
		return distance;
	}
}

